# `<Suspense>`

`<Suspense>`ë¥¼ ì‚¬ìš©í•˜ë©´ ìì‹ì´ ë¡œë”©ì„ ì™„ë£Œí•  ë•Œê¹Œì§€ í´ë°±ì„ í‘œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```javascript
<Suspense fallback={<Loading />}>
  <SomeComponent />
</Suspense>
```

## Reference

### Props

- `children`: ë Œë”ë§í•˜ë ¤ëŠ” ì‹¤ì œ UIì…ë‹ˆë‹¤. ë Œë”ë§ ë„ì¤‘ `children`ì´ ì¼ì‹œ ì¤‘ë‹¨ë˜ë©´ Suspense boundaryê°€ ë Œë”ë§ `fallback`ìœ¼ë¡œ ì „í™˜ë©ë‹ˆë‹¤.
- `fallback`: ë¡œë”©ì´ ì™„ë£Œë˜ì§€ ì•Šì€ ê²½ìš° ì‹¤ì œ UI ëŒ€ì‹  ë Œë”ë§í•  ëŒ€ì²´ UIì…ë‹ˆë‹¤. ìœ íš¨í•œ React ë…¸ë“œëŠ” ë¬´ì—‡ì´ë“  í—ˆìš©ë˜ì§€ë§Œ, ì‹¤ì œë¡œ í´ë°±ì€ ë¡œë”© ìŠ¤í”¼ë„ˆë‚˜ ìŠ¤ì¼ˆë ˆí†¤ê³¼ ê°™ì€ ê²½ëŸ‰ í”Œë ˆì´ìŠ¤í™€ë” ë·°ì…ë‹ˆë‹¤. SuspenseëŠ” ìì‹ì´ ì¼ì‹œ ì¤‘ë‹¨ë˜ë©´ ìë™ìœ¼ë¡œ `fallback`ìœ¼ë¡œ ì „í™˜ë˜ê³ , ë°ì´í„°ê°€ ì¤€ë¹„ë˜ë©´ ë‹¤ì‹œ `children`ìœ¼ë¡œ ì „í™˜ë©ë‹ˆë‹¤. ë Œë”ë§ ì¤‘ì— `fallback`ì´ ì¼ì‹œ ì¤‘ë‹¨ë˜ë©´ ê°€ì¥ ê°€ê¹Œìš´ ìƒìœ„ Suspense ê²½ê³„ê°€ í™œì„±í™”ë©ë‹ˆë‹¤.

### Caveats

- ReactëŠ” ì²˜ìŒ ë§ˆìš´íŠ¸í•˜ê¸° ì „ì— ì¼ì‹œ ì¤‘ë‹¨ëœ ë Œë”ë§ì˜ stateë¥¼ ë³´ì¡´í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì»´í¬ë„ŒíŠ¸ê°€ ë¡œë“œë˜ë©´ ReactëŠ” ì¼ì‹œ ì¤‘ë‹¨ëœ íŠ¸ë¦¬ì˜ ë Œë”ë§ì„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.
- ì¼ì‹œ ì¤‘ë‹¨ì´ íŠ¸ë¦¬ì— ëŒ€í•œ ì½˜í…ì¸ ë¥¼ í‘œì‹œí•˜ê³  ìˆë‹¤ê°€ ë‹¤ì‹œ ì¼ì‹œ ì¤‘ë‹¨ëœ ê²½ìš°, ê·¸ ì›ì¸ì´ ëœ ì—…ë°ì´íŠ¸ê°€ [`startTransition`](https://beta.reactjs.org/reference/react/startTransition) ë˜ëŠ” [`useDeferredValue`](https://beta.reactjs.org/reference/react/useDeferredValue)ë¡œ ì¸í•œ ê²ƒì´ ì•„ë‹ˆë¼ë©´ `fallback`ì´ ë‹¤ì‹œ í‘œì‹œë©ë‹ˆë‹¤.
- Reactê°€ ë‹¤ì‹œ ì¼ì‹œ ì¤‘ë‹¨ë˜ì–´ ì´ë¯¸ í‘œì‹œëœ ì½˜í…ì¸ ë¥¼ ìˆ¨ê²¨ì•¼ í•˜ëŠ” ê²½ìš°, ì½˜í…ì¸  íŠ¸ë¦¬ì—ì„œ [ë ˆì´ì•„ì›ƒ íš¨ê³¼](https://beta.reactjs.org/reference/react/useLayoutEffect)ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤. ì½˜í…ì¸ ê°€ ë‹¤ì‹œ í‘œì‹œë  ì¤€ë¹„ê°€ ë˜ë©´ ReactëŠ” ë ˆì´ì•„ì›ƒ Effectsë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì½˜í…ì¸ ê°€ ìˆ¨ê²¨ì ¸ ìˆëŠ” ë™ì•ˆ DOM ë ˆì´ì•„ì›ƒì„ ì¸¡ì •í•˜ëŠ” Effectsê°€ ì´ ì‘ì—…ì„ ì‹œë„í•˜ì§€ ì•Šë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- Reactì—ëŠ” Suspenseì™€ í†µí•©ëœ _ìŠ¤íŠ¸ë¦¬ë° ì„œë²„ ë Œë”ë§_ ë° *ì„ íƒì  ìˆ˜í™”*ì™€ ê°™ì€ ë‚´ë¶€ ìµœì í™”ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. [ì•„í‚¤í…ì²˜ ê°œìš”](https://github.com/reactwg/react-18/discussions/37)ì™€ [ê¸°ìˆ  ê°•ì—°](https://www.youtube.com/watch?v=pj5N-Khihgc)ì„ ì‹œì²­í•˜ì—¬ ìì„¸í•œ ë‚´ìš©ì„ ì•Œì•„ë³´ì„¸ìš”.

## Usage

### ì½˜í…ì¸ ê°€ ë¡œë“œë˜ëŠ” ë™ì•ˆ í´ë°± ì½˜í…ì¸  í‘œì‹œ

ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ë¶€ë¶„ì„ Suspense ê²½ê³„ë¡œ ê°ìŒ€ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```javascript
<Suspense fallback={<Loading />}>
  <Albums />
</Suspense>
```

ReactëŠ” ìì‹ì—ê²Œ í•„ìš”í•œ ëª¨ë“  ì½”ë“œì™€ ë°ì´í„°ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ë¡œë”© í´ë°±ì„ í‘œì‹œí•©ë‹ˆë‹¤.

ì•„ë˜ ì˜ˆì‹œì—ì„œëŠ” ì•¨ë²” ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë™ì•ˆ `Albums` ì»´í¬ë„ŒíŠ¸ê°€ *ì¤‘ì§€*ë©ë‹ˆë‹¤. ë Œë”ë§í•  ì¤€ë¹„ê°€ ë  ë•Œê¹Œì§€ ReactëŠ” ìœ„ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Suspense ê²½ê³„ë¥¼ ì „í™˜í•˜ì—¬ í´ë°±, ì¦‰ `Loading` ì»´í¬ë„ŒíŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ë°ì´í„°ê°€ ë¡œë“œë˜ë©´ ReactëŠ” `Loading` í´ë°±ì„ ìˆ¨ê¸°ê³  ë°ì´í„°ì™€ í•¨ê»˜ `Albums` ì»´í¬ë„ŒíŠ¸ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.

```javascript
import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>ğŸŒ€ Loading...</h2>;
}
```

> **Note**  
> **Suspense-enabledí•œ ë°ì´í„° ì›ë³¸ë§Œ Suspense ì»´í¬ë„ŒíŠ¸ë¥¼ í™œì„±í™”í•©ë‹ˆë‹¤.** ì—¬ê¸°ì—ëŠ” ë‹¤ìŒì´ í¬í•¨ë©ë‹ˆë‹¤:
>
> - [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) ë° [Next.js](https://nextjs.org/docs/advanced-features/react-18)ì™€ ê°™ì€ Suspense ì§€ì› í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
> - [lazy](https://beta.reactjs.org/reference/react/lazy)ë¡œ ì»´í¬ë„ŒíŠ¸ ì½”ë“œ ì§€ì—° ë¡œë“œí•˜ê¸°
>
> SuspenseëŠ” Effect ë˜ëŠ” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë‚´ë¶€ì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ë•Œë¥¼ ê°ì§€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
>
> ìœ„ì˜ `Albums` ì»´í¬ë„ŒíŠ¸ì—ì„œ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ì •í™•í•œ ë°©ë²•ì€ í”„ë ˆì„ì›Œí¬ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤. Suspense ì§€ì› í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° í•´ë‹¹ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ë¬¸ì„œì—ì„œ ìì„¸í•œ ë‚´ìš©ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
>
> Opinionated frameworkë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” Suspense ì§€ì› ë°ì´í„° ê°€ì ¸ì˜¤ê¸°ëŠ” ì•„ì§ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Suspense ì§€ì› ë°ì´í„° ì†ŒìŠ¤ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìš”êµ¬ ì‚¬í•­ì€ ë¶ˆì•ˆì •í•˜ê³  ë¬¸ì„œí™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë°ì´í„° ì†ŒìŠ¤ë¥¼ Suspenseì™€ í†µí•©í•˜ê¸° ìœ„í•œ ê³µì‹ APIëŠ” í–¥í›„ React ë²„ì „ì—ì„œ ì¶œì‹œë  ì˜ˆì •ì…ë‹ˆë‹¤.

### Revealing content together at once

By default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator:

```javascript
<Suspense fallback={<Loading />}>
  <Biography />
  <Panel>
    <Albums />
  </Panel>
</Suspense>
```

Then, after all of them are ready to be displayed, they will all appear together at once.

In the example below, both `Biography` and `Albums` fetch some data. However, because they are grouped under a single Suspense boundary, these components always â€œpop inâ€ together at the same time.

```javascript
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Biography artistId={artist.id} />
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>ğŸŒ€ Loading...</h2>;
}
```

Components that load data donâ€™t have to be direct children of the Suspense boundary. For example, you can move `Biography` and `Albums` into a new `Details` component. This doesnâ€™t change the behavior. `Biography` and `Albums` share the same closest parent Suspense boundary, so their reveal is coordinated together.

```javascript
<Suspense fallback={<Loading />}>
  <Details artistId={artist.id} />
</Suspense>;

function Details({ artistId }) {
  return (
    <>
      <Biography artistId={artistId} />
      <Panel>
        <Albums artistId={artistId} />
      </Panel>
    </>
  );
}
```

### Revealing nested content as it loads

When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundaryâ€™s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:

```javascript
<Suspense fallback={<BigSpinner />}>
  <Biography />
  <Suspense fallback={<AlbumsGlimmer />}>
    <Panel>
      <Albums />
    </Panel>
  </Suspense>
</Suspense>
```

With this change, displaying the `Biography` doesnâ€™t need to â€œwaitâ€ for the `Albums` to load.

The sequence will be:

1. If `Biography` hasnâ€™t loaded yet, `BigSpinner` is shown in place of the entire content area.
2. Once `Biography` finishes loading, `BigSpinner` is replaced by the content.
3. If `Albums` hasnâ€™t loaded yet, `AlbumsGlimmer` is shown in place of `Albums` and its parent `Panel`.
4. Finally, once `Albums` finishes loading, it replaces `AlbumsGlimmer`.

```javascript
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<BigSpinner />}>
        <Biography artistId={artist.id} />
        <Suspense fallback={<AlbumsGlimmer />}>
          <Panel>
            <Albums artistId={artist.id} />
          </Panel>
        </Suspense>
      </Suspense>
    </>
  );
}

function BigSpinner() {
  return <h2>ğŸŒ€ Loading...</h2>;
}

function AlbumsGlimmer() {
  return (
    <div className='glimmer-panel'>
      <div className='glimmer-line' />
      <div className='glimmer-line' />
      <div className='glimmer-line' />
    </div>
  );
}
```

Suspense boundaries let you coordinate which parts of your UI should always â€œpop inâ€ together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your appâ€™s behavior.

Donâ€™t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placedâ€”itâ€™s likely that theyâ€™ve already included them in their design wireframes.

### Showing stale content while fresh content is loading

In this example, the `SearchResults` component suspends while fetching the search results. Type `"a"`, wait for the results, and then edit it to `"ab"`. The results for `"a"` will get replaced by the loading fallback.

```javascript
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}
```

A common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The `useDeferredValue` Hook lets you pass a deferred version of the query down:

```javascript
export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={deferredQuery} />
      </Suspense>
    </>
  );
}
```

The `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.

To make it more obvious to the user, you can add a visual indication when the stale result list is displayed:

```javascript
<div
  style={{
    opacity: query !== deferredQuery ? 0.5 : 1,
  }}
>
  <SearchResults query={deferredQuery} />
</div>
```

Enter `"a"` in the example below, wait for the results to load, and then edit the input to `"ab"`. Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:

```javascript
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={(e) => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{ opacity: isStale ? 0.5 : 1 }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}
```

> **Note**  
> Both deferred values and [transitions](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding) let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it â€œlag behindâ€ the rest of the UI.

### Preventing already revealed content from hiding

```javascript
import { Suspense, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    setPage(url);
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout>{content}</Layout>;
}

function BigSpinner() {
  return <h2>ğŸŒ€ Loading...</h2>;
}
```

When you pressed the button, the `Router` component rendered `ArtistPage` instead of `IndexPage`. A component inside `ArtistPage` suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by `BigSpinner`.

To prevent this, you can mark the navigation state update as a transition with [startTransition](https://react.dev/reference/react/startTransition):

This tells React that the state transition is not urgent, and itâ€™s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button â€œwaitsâ€ for the `Biography` to load:

```javascript
import { Suspense, startTransition, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout>{content}</Layout>;
}

function BigSpinner() {
  return <h2>ğŸŒ€ Loading...</h2>;
}
```

A transition doesnâ€™t wait for _all_ content to load. It only waits long enough to avoid hiding already revealed content. For example, the website `Layout` was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested `Suspense` boundary around `Albums` is new, so the transition doesnâ€™t wait for it.

> **Note**  
> Suspense-enabled routers are expected to wrap the navigation updates into transitions by default.

### Indicating that a transition is happening

In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace `startTransition` with `useTransition` which gives you a boolean isPending value. In the example below, itâ€™s used to change the website header styling while a transition is happening:

```javascript
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = <IndexPage navigate={navigate} />;
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return <Layout isPending={isPending}>{content}</Layout>;
}

function BigSpinner() {
  return <h2>ğŸŒ€ Loading...</h2>;
}
```

### Resetting Suspense boundaries on navigation

During a transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a `key`:

```javascript
<ProfilePage key={queryParams.id} />
```

Imagine youâ€™re navigating within a userâ€™s profile page, and something suspends. If that update is wrapped in a transition, it will not trigger the fallback for already visible content. Thatâ€™s the expected behavior.

However, now imagine youâ€™re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one userâ€™s timeline is different content from another userâ€™s timeline. By specifying a `key`, you ensure that React treats different usersâ€™ profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.

### Providing a fallback for server errors and server-only content

If you use one of the [streaming server rendering APIs](https://react.dev/reference/react-dom/server) (or a framework that relies on them), React will also use your `s` boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest `s` component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.

On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest [error boundary](https://react.dev/reference/react/Component#static-getderivedstatefromerror). However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.

You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a `<Suspense>` boundary to replace their HTML with fallbacks:

```javascript
<Suspense fallback={<Loading />}>
  <Chat />
</Suspense>;

function Chat() {
  if (typeof window === 'undefined') {
    throw Error('Chat should only render on the client.');
  }
  // ...
}
```

The server HTML will include the loading indicator. It will be replaced by the `Chat` component on the client.

## Troubleshooting

### How do I prevent the UI from being replaced by a fallback during an update?

Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.

To prevent this from happening, [mark the update as non-urgent using startTransition](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding). During a transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:

```javascript
function handleNextPageClick() {
  // If this update suspends, don't hide the already displayed content
  startTransition(() => {
    setCurrentPage(currentPage + 1);
  });
}
```

This will avoid hiding existing content. However, any newly rendered `Suspense` boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.

**React will only prevent unwanted fallbacks during non-urgent updates.** It will not delay a render if itâ€™s the result of an urgent update. You must opt in with an API like [startTransition](https://react.dev/reference/react/startTransition) or [useDeferredValue](https://react.dev/reference/react/useDeferredValue).

If your router is integrated with Suspense, it should wrap its updates into [startTransition](https://react.dev/reference/react/startTransition) automatically.
